import "util.scrypt";
import "txUtil.scrypt";
/**
 * A non-fungible token enforced by miners at layer 1
 */
contract SPVToken {
    @state
    bytes tokenId;

    @state
    PubKey owner;

    // uninitialized token ID
    static const int TokenIdLen = Constants.TxIdLen;
    static const int PrevTxIdIdx = 5;
    static const int UnlockingScriptIdx = 41;
 
    static const bytes NullTokenId = num2bin(0, TokenIdLen);

    // prevTx: tx being spent by the current tx
    // prevPrevTx: tx being spent by prevTx
    public function transfer(Sig senderSig, PubKey receiver, int satoshiAmount, SigHashPreimage txPreimage, bytes prevTx, bytes prevPrevTx) {

        // authorize
        require(checkSig(senderSig, this.owner));

        bytes outpoint = SigHash.outpoint(txPreimage);
        bytes prevTxId = outpoint[: TokenIdLen];
        require(hash256(prevTx) == prevTxId);

        if (this.tokenId == NullTokenId) {
            // get prevTxId and use it to initialize token ID
            this.tokenId = prevTxId;
        }
        else {
            /*
            * validate not only the parent tx (prevTx), but also its parent tx (prevPrevTx)
            */

            // TODO: assume 1 input, to extend to multiple inputs
            bytes prevPrevTxId = prevTx[PrevTxIdIdx : PrevTxIdIdx + Constants.TxIdLen];
            require(hash256(prevPrevTx) == prevPrevTxId);
            // TODO: only validate output 0 here, to extend to multiple outputs
            bytes contractScript = TxUtil.readOutput(prevPrevTx, 0).script;
            ScriptCode prevSc = Util.parseScriptCode(contractScript);
            ScriptCode sc = Util.parseScriptCode(SigHash.scriptCode(txPreimage));
            bytes prevTokenId = prevSc.dataPart[ : TokenIdLen];
            // ensure prev tx uses the same contract code
            require(prevSc.codePart == sc.codePart);
            // belongs to the same token
            require(prevTokenId == this.tokenId || prevTokenId == NullTokenId);
        }

        this.owner = receiver;

        require(this.propagateState(txPreimage, satoshiAmount));
    }

    // propagate state to the next UTXO
    function propagateState(SigHashPreimage preimage, int amount) : bool {
        require(Tx.checkPreimageSigHashType(preimage, SigHash.SINGLE | SigHash.FORKID));
        bytes outputScript = this.getStateScript();
        bytes output = Utils.buildOutput(outputScript, amount);
        return hash256(output) == SigHash.hashOutputs(preimage);
    }
}
