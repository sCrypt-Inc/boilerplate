contract Util {
	// number of bytes to denote some numeric value
    static int DataLen = 1;

	// number of bytes to denote output value
    static int OutputValueLen = 8;
	// number of bytes to denote a public key (compressed)
    static int PubKeyLen = 33;
	// number of bytes to denote a public key hash
    static int PubKeyHashLen = 20;

    static function readVarint(bytes b): bytes {
		int l = 0;
		bytes ret = b'';
		bytes header = b[0:1];

		if (header == b'fd') {
			l = this.fromLEUnsigned(b[1:3]);
			ret = b[3:3+l];
		} else if (header == b'fe') {
			l = this.fromLEUnsigned(b[1:5]);
			ret = b[5:5+l];
		} else if (header == b'ff') {
			l = this.fromLEUnsigned(b[1:9]);
			ret = b[9:9+l];
		} else {
			l = this.fromLEUnsigned(b[0:1]);
			ret = b[1:1+l];
		}

		return ret;
	}

    static function writeVarint(bytes b): bytes {
		int n = len(b);
		
		bytes header = b'';

		if (n < 0xfd) {
			header = this.toLEUnsigned(n, 1);
		} else if (n < 0x10000) {
			header = b'fd' + this.toLEUnsigned(n, 2);
		} else if (n < 0x100000000) {
			header = b'fe' + this.toLEUnsigned(n, 4);
		} else if (n < 0x10000000000000000) {
			header = b'ff' + this.toLEUnsigned(n, 8);
		}

		return header + b;
	}

    // convert signed integer `n` to unsigned integer of `l` bytes, in little endian
	static function toLEUnsigned(int n, int l): bytes {
		// one extra byte to accommodate possible negative sign byte
		bytes m = num2bin(n, l + 1);
		// remove sign byte
		return m[0 : len(m) - 1];
	}

    static function fromLEUnsigned(bytes b): int {
		// append positive sign byte. This does not hurt even when sign bit is already positive
		return unpack(b + b'00');
	}

	static function buildPublicKeyHashScript(Ripemd160 pubKeyHash): bytes {
	 	return OpCode.OP_DUP + OpCode.OP_HASH160 + pack(Util.PubKeyHashLen) /* "OP_PUSHDATA0" */ + 
		 		pubKeyHash + OpCode.OP_EQUALVERIFY + OpCode.OP_CHECKSIG;
	}

	// build a tx output from its script and satoshi amount
	static function buildOutput(bytes outputScript, int outputSatoshis): bytes {
		return num2bin(outputSatoshis, Util.OutputValueLen) + Util.writeVarint(outputScript);
	}

	/*
	 * parse sighash preimage
	 * Note: only to be used after preimage is validated
	 * spec is at https://github.com/bitcoin-sv/bitcoin-sv/blob/master/doc/abc/replay-protected-sighash.md
	 */
	static function nVersion(bytes preimage): bytes {
		return preimage[:4];
	}

	static function hashPrevouts(bytes preimage): bytes {
		return preimage[4:36];
	}
	
	static function hashSequence(bytes preimage): bytes {
		return preimage[36:68];
	}

	static function outpoint(bytes preimage): bytes {
		return preimage[68:104];
	}

	// scriptCode is just scriptPubKey if there is no CODESEPARATOR in the latter
	static function scriptCode(bytes preimage): bytes {
		return Util.readVarint(preimage[104:]);
	}

	static function valueRaw(bytes preimage): bytes {
		int l = len(preimage);
		return preimage[l - 52 : l - 44];
	}

	static function value(bytes preimage): int {
		return Util.fromLEUnsigned(Util.valueRaw(preimage));
	}

	static function nSequenceRaw(bytes preimage): bytes {
		int l = len(preimage);
		return preimage[l - 44 : l - 40];
	}

	static function nSequence(bytes preimage): int {
		return Util.fromLEUnsigned(Util.nSequenceRaw(preimage));
	}

	static function hashOutputs(bytes preimage): bytes {
		int l = len(preimage);
		return preimage[l - 40 : l - 8];
	}

	static function nLocktimeRaw(bytes preimage): bytes {
		int l = len(preimage);
		return preimage[l - 8 : l - 4];
	}

	static function nLocktime(bytes preimage): int {
		return Util.fromLEUnsigned(Util.nLocktimeRaw(preimage));
	}

	static function sigHashType(bytes preimage): SigHashType {
		int l = len(preimage);
		return SigHashType(preimage[l - 4 :]);
	}

    public function testPreimageParsing(bytes preimage) {
			require(Tx.checkPreimage(preimage));
		bytes preimage_ = Util.nVersion(preimage) + Util.hashPrevouts(preimage) + Util.hashSequence(preimage) +
						  Util.outpoint(preimage) + Util.writeVarint(Util.scriptCode(preimage)) + Util.valueRaw(preimage) +
            			  Util.nSequenceRaw(preimage) + Util.hashOutputs(preimage) + Util.nLocktimeRaw(preimage) + Util.sigHashType(preimage);
        require(preimage == preimage_);
    }
}