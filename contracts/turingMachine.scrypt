import "util.scrypt";
import "serializer.scrypt";

// Turing machine state
type State = bytes;
// alphabet symbol in each cell, 1 byte long each
type Symbol = bytes;

// contract state as a struct
struct StateStruct {
    int headPos;
    bytes tape;
    // current machine state
    State curState;
}

struct Input {
    State oldState;
    Symbol read;
}

struct Output {
    State newState;
    Symbol write;
    // move left or right
    bool moveLeft;
}

// transition function entry: input -> output
struct TransitionFuncEntry {
    Input input;
    Output output;
}

/*
 * A Turing Machine checking balanced parentheses
 */
contract TuringMachine {
    // states
    static const State STATE_A = b'00';     // initial state
    static const State STATE_B = b'01';
    static const State STATE_C = b'02';
    static const State STATE_ACCEPT = b'03';
    
    // symbols
    static const Symbol BLANK = b'00';
    static const Symbol OPEN  = b'01';
    static const Symbol CLOSE = b'02';
    static const Symbol X     = b'03';

    static const bool LEFT = true;
    static const bool RIGHT = false;

    // number of rules in the transition function
    static const int N = 8;
    // transition function table
    static const TransitionFuncEntry[N] transitionFuncTable = [
        {{STATE_A, OPEN},   {STATE_A, OPEN, RIGHT}},
        {{STATE_A, X},      {STATE_A, X, RIGHT}},
        {{STATE_A, CLOSE},  {STATE_B, X, LEFT}},
        {{STATE_A, BLANK},  {STATE_C, BLANK, LEFT}},
        
        {{STATE_B, OPEN},   {STATE_A, X, RIGHT}},
        {{STATE_B, X},      {STATE_B, X, LEFT}},

        {{STATE_C, X},      {STATE_C, X, LEFT}},
        {{STATE_C, BLANK},  {STATE_ACCEPT, BLANK, RIGHT}}
    ];

    public function transit(SigHashPreimage txPreimage, int amount) {
        // read/deserialize contract state
        require(Tx.checkPreimage(txPreimage));
        bytes scriptCode = Util.scriptCode(txPreimage);
        int stateStart = Reader.getStateStart(scriptCode);
        StateStruct s = deserialize(scriptCode[stateStart :]);
        
        // transition
        Symbol head = Util.getElemAt(s.tape, s.headPos);
        // look up in transition table
        bool found = false;
        loop (N) : i {
            if (!found) {
                auto entry = transitionFuncTable[i];
                if (entry.input == {s.curState, head}) {
                    auto output = entry.output;
                    // update state
                    s.curState = output.newState;
                    // write tape head
                    s.tape = Util.setElemAt(s.tape, s.headPos, output.write);
                    // move head
                    s.headPos += output.moveLeft ? -1 : 1;
                    // extend tape if out of bound
                    if (s.headPos < 0) {
                        // add 1 blank cell to the left
                        s.tape = BLANK + s.tape;
                        s.headPos = 0;
                    } else if (s.headPos >= len(s.tape))  {
                        // add 1 blank cell to the right
                        s.tape = s.tape + BLANK;
                    }

                    if (s.curState == STATE_ACCEPT) {
                        // accept
                        exit(true);
                    }

                    found = true;
                }
            }
        }
        // reject if no transition rule found
        require(found);

        // otherwise machine goes to the next step

        // write/serialize contract state
        bytes stateBuf = serialize(s);
        bytes scriptCode_ = scriptCode[: stateStart] + stateBuf;
        bytes output = Util.buildOutput(scriptCode_, amount);
        require(hash256(output) == Util.hashOutputs(txPreimage));
    }

    
    // helper functions to de/serialize contract state, not machine state

    static function deserialize(bytes buf) : StateStruct {
        Reader r = new Reader(buf);
        auto headPos = r.readInt();
        auto tape = r.readBytes();
        auto curState = r.readBytes();

        return { headPos, tape, curState };
    }

    static function serialize(StateStruct s) : bytes {
        bytes sBuf = Writer.writeInt(s.headPos) + Writer.writeBytes(s.tape) + Writer.writeBytes(s.curState);
        return Writer.serializeState(sBuf);
    }
}
